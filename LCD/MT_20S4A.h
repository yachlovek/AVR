/*
 * Заголовочный файл для работы с ЖКИ MT-20S4A.
 * Используемый МК: Mega8515.
 * Режим обмена данными с ЖКИ: 4-х битный.
 * Используемый порт: С
 * Диапазон пинов управления: 0-2
 * Диапазон пинов данных: 4-7
 */

/*
 * Порт МК для работы с ЖКИ
 */
#define LCD_DDR DDRC
#define LCD_PORT PORTC

/*
 * Номера пинов управления ЖКИ
 */
#define A0 0 //Адресный пин
#define RW 1 //Пин выбора режима чтения/записи
#define E 2 //Пин разрешения обращения к модулю (строб данных)

/*
 * Адреса Управляющих команд
 */
#define CLEAR_DISPLAY 0x01 //Очистка модуля и помещение курсора в самую левую позицию
#define RETURN_HOME 0x02 //Перемещение курсора в левую позицию
#define ENTRY_MODE_SET 0x04 //Установка режима записи (См. управляющие биты ID и SH)
#define DISPLAY_ON_OFF_CONTROL 0x08 //Управление дисплеем (См. управляющие биты D, C, B)
#define CURSOR_OR_DISPLAY_SHIFT 0x10 //Сдвиг дисплея/курсора влево/вправо (См. управляющие биты SC, RL)
#define FUNCTION_SET 0x28 //Установка разрядности интерфейса и страницы знакорегистра (См. управляющие биты DL, P)
#define SET_CGRAM_ADDRESS 0x40 //Установка адреса для последующих операций  (и установка туда курсора) и выбор области CGRAM 
#define SET_DDRAM_ADDRESS 0x80 //Установка адреса для последующих операций и выбор области DDRAM

/*
 * Предопределенные адреса управляющих битов
 */
#define WRITE_COMMAND 0x00 //Передача команды
#define DATA 0x02 //Передача данных
#define READ_BUSY_FLAG_AND_ADDRESS 0X02 //Проверка флага занятости BS
#define WRITE_DATA 0x01 //Запись данных
#define READ_DATA 0x03 //Чтение данных

/*
 * Управляющие биты
 */
#define SH 0 //Разрешение сдвига дисплея
#define ID 0 //Направление сдвига дисплея (0/1 - влево/вправо)
#define B 0 //Мигание курсора 0/1 - выкл./вкл.
#define C 1 //Наличие курсора 0/1 - выкл./вкл. 
#define D 2 //Дисплей 0/1 - выкл./вкл.
#define RL 2 //Направление сдвига 0/1 - влево/вправо
#define SC 3 //Сдвиг курсора/дисплея 0/1 - курсор/дисплей
#define P 1 //Страница знакорегистра 0/1 - стр.1/стр.2 (См. таблицу символов в даташите)
#define DL 4 //Разрядность интерфейса 0/1 - 4/8 бита

/*
 * Начальные адреса строк
 */
#define ROW0 0x00 //строка 1
#define ROW1 0x40 //строка 2
#define ROW2 0x14 //строка 3
#define ROW3 0x54 //строка 4

/*
 * Начальные адреса дисплеев
 */
#define DISPL1 0x00 //Дисплей 1
#define DISPL2 0x0A //Дисплей 2

/*
 * Функции МК
 */
void mk_mode_write(void); //Установка режима записи из МК в ЖКИ
void mk_mode_read(void); //Установка режима чтения в МК из ЖКИ

/*
 * Функции настройки и взаимодействия с ЖКИ
 */
char lcd_checkBS(void); //Проверка бита занятости
void lcd_write(char data, char type_data); //Запись данных в ЖКИ
void lcd_init(void); //Инициализация ЖКИ

/*
 * Функции отображения данных на ЖКИ
 */
void lcd_print(char *str); //Вывод текста в ЖКИ




/*
 * Настройка портов МК за запись/чтение
 */
void mk_mode_write(void) //Запись данных в ЖКИ
{
	LCD_DDR = 0xFF;
	LCD_PORT = 0x00;
}

void mk_mode_read(void) //Чтение данных из ЖКИ
{
	LCD_DDR = 0xFF & 0x0F;
	LCD_PORT = 0x0F;
}

/*
 * Функции настройки и взаимодействия с ЖКИ
 */
char lcd_checkBS(void) //Проверка бита занятости
{
	char flag_bs; //Флаг занятости ЖКИ

	mk_mode_read(); //Перевод МК в режим чтения

	//Чтение бита занятости
	LCD_PORT = READ_BUSY_FLAG_AND_ADDRESS; //Установка управляющих битов
	delay_us(40);

	LCD_PORT |= (1<<E); //Установка разрешения на обращение к ЖКИ
	delay_us(1);

	LCD_PORT &= ~(1<<E); //Снятие разрешения на обращение к ЖКИ
	flag_bs = LCD_PORT; //Чтение установившегося значения на порту МК

	//Завершение чтения бита занятости
	LCD_PORT |= (1<<E);
	delay_us(1);

	LCD_PORT &= ~(1<<E);
	delay_us(5);

	flag_bs &= (1<<7); //Выделение значения бита занятости
	      
	return flag_bs; //Возвращение значения бита занятости
}

void lcd_write(char data, char type_data) //Запись команды/данных в ЖКИ. В type_data передается предопределенный адрес управляющих битов
{
	char data_h = data & 0xF0; //Выделение старшей тетрады данных
    char data_l = (data & 0x0F) << 4; //Выделение младшей тетрады данных и сдвиг ее в старшую тетраду

    while(lcd_checkBS()); //Ожидания освобождения бита занятости

    mk_mode_write(); //Перевод МК в режим записи

	LCD_PORT = data_h|type_data; //Установка старшей тетрады данных и управляющих битов на порту МК
    delay_us(40);

    LCD_PORT |= (1<<E); //Установка разрешения обращения к ЖКИ
	delay_us(80);

	LCD_PORT &= ~(1<<E); //Снятие разрешения обращения к ЖКИ
	LCD_PORT = data_l|type_data; //Установка младшей тетрады данных и управляющих битов на порту МК
	LCD_PORT |= (1<<E); //Установка разрешения обращения к ЖКИ
	delay_us(80);

	LCD_PORT &= ~(1<<E); //Снятие разрешения обращения к ЖКИ
	delay_ms(10);

	LCD_PORT = 0x03; //Установка начальных значений битов на порту A0 и RW
}

void lcd_init(void) //Инициализация ЖКИ
{
	delay_ms(20);

    lcd_write(0x30, WRITE_COMMAND); //Установка разрядности интерфейса
    delay_us(40);

    lcd_write(0x30, WRITE_COMMAND); //Установка разрядности интерфейса
    delay_us(40);

    lcd_write(0x30, WRITE_COMMAND); //Установка разрядности интерфейса
    delay_us(40);

    lcd_write(0x20, WRITE_COMMAND); //Установка разрядности интерфейса
    delay_us(40);

    lcd_write(0x2A, WRITE_COMMAND); //Установка разрядности интерфейса и страницы знакорегистра
    lcd_write(0x08, WRITE_COMMAND); //Выключение дисплея
    lcd_write(0x01, WRITE_COMMAND); //Очистка дисплея
    lcd_write(0x06, WRITE_COMMAND); //Установка режима ввода данных
}

/*
 * ---------------------------------
 * Функции отображения данных на ЖКИ
 * ---------------------------------
 */

void lcd_print(char *str) //Вывод текста в ЖКИ
{
	int i;    
    
    for(i = 0; str[i] != '\0'; i++)
    {    
        while(lcd_checkBS());
        
        lcd_write(str[i], WRITE_DATA);
    }
}
